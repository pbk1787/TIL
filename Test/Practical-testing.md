  ## 개요
 > [인프런] Practical Testing: 실용적인 테스트 가이드를 학습하며 작성하였습니다.
 >  - [테스트 샘플 프로젝트](https://github.com/pbk1787/test-cafekiosk "sample project link")

------------
 ### 테스트가 필요한 이유는 무엇일까?
    - 테스트 코드가 없다면 프로덕션 코드를 계속 개발하고 고도화 하면서..
    - 커버할 수 없는 영역 발생
    - 프로젝트를 오래 작업한 개발자의 경험과 감에 의존
    - 늦은 피드백
    - 유지보수 어려움
    - 소프트웨어 신뢰 ↓ 어디서 버그가 터질지 모르는 시한폭탄이 될 수 있다


### 테스트를 추가하면서 얻고자 하는 것
    - 빠른 피드백
    - 자동화
    - 안정감, 신뢰성

### 테스트 코드를 작성하지 않는다면
    - 변화가 생기는 매 순간마다 발생할 수 있는 모든 Case를 고려해야 한다
    - 변화가 생기는 매 순간마다 모든 팀원이 동일한 고민을 해야한다
    - 빠르게 변화하는 소프트웨어의 안정성을 보장할 수 없다

### 테스트 코드가 병목이 된다면
    - 프로덕션 코드의 안정성을 제공하기 힘들어진다
    - 테스트 코드 자체가 유지보수하기 어려운, 새로운 짐이 된다
    - 잘못된 검증이 이루어질 가능성이 생긴다

### 올바른 테스트 코드는
    - 자동화 테스트로 비교적 빠른 시간 안에 버그를 발견할 수 있고, 수동 테스트에 드는 비용을 크게 절약할 수 있다
    - 소프트웨어의 빠른 변화를 지원한다
    - 팀원들의 집단 지성을 팀 차원의 이익으로 승격시킨다
    - 가까이 보면 느리지만, 멀리 보면 가장 빠르다

---

### 단위 테스트
- 작은 코드 단위(class or method)를 독립적으로 검증하는 테스트
- 검증 속도가 빠르고, 안정적이다
- JUnit5: 단위 테스트를 위한 테스트 프레임워크
    - XUnit 시리즈(SUnit, NUnit, JUnit 등등..) - 개발자: Kent Beck
- AssertJ: 테스트 코드 작성을 원활하게 돕는 테스트 라이브러리
    - 풍부한 API, 메서드 체이닝 지원
    - 주로 JUnit과 함께 사용

### 테스트 케이스 세분화하기
- 요구사항이 생겼을 때, 암묵적이거나 아직 드러나지 않은 요구 사항이 있는지 질문을 계속 던져야 한다
    → 암묵적으로 숨어있는 예외 케이스를 도출하여 작성해야 한다
- 해피 케이스: 요구사항을 만족하는 테스트 케이스
- 예외 케이스: 요구사항에 대한 예외 케이스

- 경계값 테스트
    - 범위(이상, 이하, 초과, 미만), 구간, 날짜 등

### 테스트하기 어려운 영역을 구분하고 분리하기

- 테스트하기 어려운 영역
    - 관측할 때마다 다른 값에 의존하는 코드
        ex) 현재 날짜/시간, 랜덤 값, 전역 변수/함수, 사용자 입력
    - 외부 세계에 영향을 주는 코드
        ex) 표준 출력, 메시지 발송(메일 전송), 데이터베이스에 기록하기
        
- 순수함수 (pure functions: 외부 세계와 단절된 함수)
    - 같은 입력에는 항상 같은 결과
    - 외부 세상과 단절된 형태
    - 테스트하기 쉬운 코드
- 테스트 하기 어려운 영역을 외부로 분리하자
    - 외부로 분리할수록 테스트 가능한 코드는 많아진다
    - 어느 외부까지 분리를 해야할까요?
    
--------

### TDD: Test Driven Development
- 프로덕션 코드보다 테스트 코드를 먼저 작성하여 테스트가 구현 과정을 주도하도록 하는 방법론
    - RED: 실패하는 테스트 작성
        - 포로덕션 코드(구현부)가 없으니 당연히 에러 발생
    - GREEN: 빠른 시간내에 테스트를 통과하도록 구현부를 작성
        - 테스트만 통과할 수 있다면  엉터리여도 된다
        - 테스트가 통과할 수 있는 최소한의 코딩
    - REFACTOR
        - 테스트 통과를 유지하면서 구현 코드 개선
- 기존 선 기능 구현, 후 테스트 작성 시 단점
    - 테스트 자체의 누락 가능성
    - 특정 테스트 케이스(해피 케이스)만 검증할 가능성
    - 잘못된 구현을 다소 늦게 발견한 가능성
- 선 테스트 작성, 후 기능 구현시(TDD) 장점
    - 복잡도가 낮은(유연하며 유지보수가 쉬운), 테스트 가능한 코드로 구현할 수 있게 한다
    - 쉽게 발견하기 어려운 엣지(Edge) 케이스를 놓치지 않게 해준다
    - 구현에 대한 빠른 피드백을 받을 수 있다
    - 과감한 리팩토링이 가능해진다
- TDD: 관점의 변화
    - 테스트는 구현부 검증을 위한 보조 수던 → 테스트와 상호 작용하며 발전하는 구현부
    - 클라이언트 관점에서 피드백을 주는 Test Driven

------
### 테스트는 문서다
    - 프로덕션 기능을 설명하는 테스트 코드 문서
    - 다양항 테스트 케이스를 통해 프로덕션 코드를 이해하는 시각과 관점을 보완
    - 어느 한 사람이 과거에 경험했던 고민의 결과물을 팀 차원으로 승격시켜서, 모두의 자산으로 공유 가능

-----

### BDD: Behavior Driven Development

- TDD에서 파생된 개발 방법
- 함수 단위의 테스트에 집중하기보다, 시나리오에 기반한 테스트 케이스(TC) 자체에 집중하여 테스트 한다
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 수준(레벨)을 권장
- given: 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 등)
- when:  시나리오 행동 진행
- then : 시나리오 진행에 대한 결과 명시, 검증
- 어떤 환경에서 (given) 어떤 행동을 진행했을 때 (when) 어떤 상태 변화가 일어난다 (then)
    
    ⇒ DisplayName에 명확하게 작성할 수 있다
    
-----

### 통합 테스트

    - 여러 모듈이 협력하는 기능을 통합적으로 검증하는 테스트
    - 일반적으로 작은 범위의 단위 테스트만으로는 기능 전체의 신뢰성을 보장할 수 없다
    - 풍부한 단위 테스트 & 큰 기능 단위를 검증하는 통합 테스트

### Spring 

- Library vs Framework 차이
    - Library 같은 경우는 내 코드가 주체가 된다.
        - 필요한 기능을 외부에 있는 이미 개발된 기능을 가져와서 사용
    - Framework 이미 동작할 수 있는 환경이 구성된 Frame이 있어서 내 코드가 수동적으로 이 Frame안에 들어가서 기능을 수행하게 됨
- IoC (Inversion of Control)
    - 객체의 생명주기를 3자가 주관하게 되는 것
- DI (Dependency Injection)
    - 의존성을 외부에서 주입받는 것
- AOP (Aspect Oriented Programming)
    - 비즈니스 흐름과 관계없는 부분 = 관점을 모아서 모듈로 분리
    - spring에서는 proxy를 사용하여 구현하고 있다
    - ex) transaction

----

### JPA

- ORM (Object-Relational Mapping)
    - 객체 지향 패러다임과 관계형 DB 패러다임의 불일치
    - 이전에는 개발자가 객체의 데이터를 하나씩 매핑하여 DB에 저장 및 조회
    - ORM을 사용함으로써 개발자는 단순 작업을 줄이고, 비즈니스 로직에 집중할 수 있다
- JPA
    - Java 진영의 ORM 기술 표준
    - 인터페이스이고, 여러 구현제가 있지만 보통 Hibernate를 많이 사용
    - 반복적인 CRUD SQL을 생성 및 실행해주고, 여러 부가 기능들을 제공한다
    - 편리하지만 쿼리를 직접 작성하지 않기 때문에, 어떤 식으로 쿼리가 만들어지고 실행되는지 명확하게 이해하고 있어야 한다
    - Spring 진영에서는 JPA를 한번 더 추상화한 Spring Data JPA 제공
    - QueryDSL과 조합하여 많이 사용 (타입 체크, 동적 쿼리)

----

### Layerd Architecture
    왜 레이어를 분리하는가? → 관심사의 분리

- Persistence Layer
    - Data Access의 역활
    - 비즈니스 가공 로직을 포함하면 안된다
    - Data에 대한 CRUD에만 집중한 레이어

- Business Layer
    - 비즈니스 로직을 구현하는 역할
    - Persistence Layer와의 상호작용을 통해 비즈니스 로직 전개
    - 트랜잭션을 보장해야 한다

- Presentation Layer
    - 외부 세계의 요청을 가장 먼저 받는 계층
    - 파라미터에 대한 최소한의 검증을 수행한다
        - 비즈니스 로직X

-----

### @Transactional

- readOnly = true 값의 의미는? (readOnly의 기본 값은 false이다)
    - 읽기 전용 트랜잭션
    - CRUD에서 CUD 동작 X / 조회만 가능
    - JPA에서는 CUD 스냅샷 저장, 변경감지 X (성능 향상)
    - CQRS - Command / Read
        - 보통의 서비스는 Read작업이 Command보다 훨씬 많음
        - DB에 대한 Endpoint를 분리할 수 있어 장애 격리를 할 수 있음        
            ex) master = write / slave = read

-----

### MockMvc

    Mock(가짜) 객체를 사용해 스프링 MVC 동작을 재현할 수 있는 프레임워크

### Test Double

    테스트 대역

- Dummy: 아무것도 하지않는 깡통 객체
- Fake: 단순한 형태로 동일한 기능은 수행하나, 프로덕션에서 쓰기에는 부족한 객체
- Stub: 테스트에서 요청한 것에 대해 미리 준비한 결과를 제공하는 객체 그 외에는 응답하지 않는다
    
    ⇒ 상태 검증(State Verification)
    
- Spy: Stub이면서 호출된 내용을 기록하여 보여줄 수 있는 객체. 일부는 실제 객체처럼 동작시키고 일부만 stubbing할 수 있다
- Mock: 행위에 대한 기대를 명세하고, 그에 따라 동작하도록 만들어진 객체
    
    ⇒ 행위 검증(behavior Verification)

-----
### Classicist vs Mockist

- Mockist
    - 단위 테스트로 이미 기능 검증을 했으니 통합 테스트시 Mocking 처리하여 빠르고 간단하게 테스트
    - presentation layer, business layer, persistence layer 모두 Mocking 하여 테스트
- Classicist
    - 실제 프로덕션 코드를 검증하기 위해서 진짜 객체로 해야한다
    - 꼭 필요한 경우에만 Mock 처리를 하자
    - repository test: persistence layer
    - service test (통합 테스트 business layer, persistence layer)
    - controller test (service mocking하여 테스트) parameter 검증 test
    
    Q. 실제 프로덕션 코드에서 런타임 시점에 일어날 일을 정확하게 Stubbing 했다고 단언할 수 있는가?
    
        그런 리스크를 안고 갈 바에는 비용을 더 들여 실제 구현체를 불러와서 테스트하는 것이 훨씬 낫다
    
------

#### Q. 서비스 테스트를 하면 이전에 한 테스트 데이터끼리 영향을 끼치고 있어서 @AfterEach 메소드를 통해 테스트가 끝나면 clear해주는 로직을 구성해야한다. 하지만 Repository를 테스트하였을 땐 clear를 해주지 않아도 되는데 이유가 무엇일까?
    - Repository 테스트를 할 때에는 Rollback으로 인한 clear가 이루어진다.
        - Service 는 SpringBootTest 어노테이션을 달아 테스트하였다.
        - Repository는 DataJpaTest 어노테이션을 달아 테스트하였다.
    - DataJpaTest 안에는 Transactional 이 걸려있어 자동으로 롤백이 된다. (SpringBootTest 에는 없음)

#### Q. DataJpaTest처럼 SpringBootTest 쓸 때 Transactional 어노테이션을 수동으로 붙여 사용하면 되지 않나요?

    - 수동으로 어노테이션을 붙였을 때 테스트 완료 후 따로 Clear하지 않아도 Rollback이 된다.
    - Test코드에 Transactional을 붙여서 사용하면 안되는 이유?
        - 테스트 코드가 아닌 프로덕션 코드에 트랜잭션이 설정되어있는지 모호해진다
        - 트랜잭션 경계가 모호해진다. (큰 이슈 발생 가능)

-----

### 테스트 작성시 유의 사항
1. 하나의 테스트에는 하나의 주제/하나의 검증을 가져야 한다.
    - 테스트 코드내에 반복문, 분기문 등을 넣는 것을 지양해야한다.
2. 테스트하기 위한 모든 조건을 완벽하게 제어할 수 있어야한다
    - 제어할 수 없는 값(ex. 랜덤값, 현재 시간 등)은 상위 계층으로 분리하여 테스트 가능한 구조로 만드는 것
    - 외부 시스템과의 연동이 있는 경우 mocking 처리하여 테스트를 작성
    - 현재 시간 값은 되도록 쓰지 않는 것이 좋다. 다른 환경에서 테스트시 해당 서버의 시간이 달라서 문제가 생길 가능성이 있기 때문. 따라서 테스트할 때에는 고정된 시간, 고정된 값으로 테스트하는 것이 좋다.
3. 테스트 환경의 독립성을 보장하자
    - 테스트 환경을 조성할 때 (given절에서) 최대한 생성자, 순수한 빌더 기반으로 구성하는 것이 좋다
    - 팩토리 메서드도 지양하는 것이 좋다
4. 테스트 간 독립성을 보장하자
    - 공유 자원 사용을 지양하자
    - 두 가지 이상의 테스트가 하나의 공유 자원을 사용하면 테스트 순서에 따라 테스트 결과가 달라질 수 있다.
    - 테스트간에는 순서와 무관하여야 하며, 각각 독립적으로 항상 같은 결과를 내어야 한다.

----

### Test Fixture
- Fixture: 고정물, 고정되어 있는 물체
- 테스트를 위해 원하는 상태로 고정시킨 일련의 객체
- given절을 구성할 때 주로 사용
- @BeforeAll: 테스트 클래스 전체 실행 전에 한번 실행됨
- @BeforeEach: 매 테스트 메소드 실행 전에 작업
    - 공유 변수를 사용하게되어 사용을 지양하는 것이 좋다
    - 테스트 메소드가 많아지게 되면 문서로서의 역할을 하기가 어려워짐
    - beforeEach를 사용해도 좋을 때 (아래 두 가지를 모두 만족하여야 함)
        - beforeEach에 적힌 내용을 몰라도 테스트 내용을 이해하는데 문제가 없는가?
        - 수정해도 모든 테스트에 영향을 주지 않는가?
- @AfterAll: 테스트 클래스 전체가 끝나고 한번 실행됨
- @AfterEach: 매 테스트 메소드 종류 후에 작업
- data.sql 같이 다른 곳에서 미리 셋업하는 형태도 데이터의 파편화가 일어나고 유지보수 포인트로 늘어나게 되어 사용을 지양해야한다.
- given fixture를 구성할때 필요한 parameter만 받아서 무엇을 테스트 할지 명확하게 해준다
- fixture를 만드는 것을 하나의 공통 클래스로 모아서 만드는 것을 지양하자. 필드 검사 복잡도가 올라가기 때문(코틀린을 사용하면 이렇게 구성해볼 수 있을 것)

### Test Fixture 클렌징
- @Transactional 어노테이션을 사용하여 자동 rollback 처리
    
    → 사이드 이펙트에 대해 충분히 인지하며 사용하여야 한다
    
- @AfterEach를 사용하여 매 테스트가 끝날때마다 저장된 데이터를 지워준다
    - deleteAll:  삭제할 테이블의 연관관계 매핑 테이블도 모두 조회하여 한 row 단위로 건 당 삭제. 여러 개의 테이블을 삭제할 때 순서를 아예 고려를 안해야하는 것은 아니다. 삭제 비용이 많이 들게됨.
    - deleteAllInBatch: 테이블 전체를 벌크성으로 지워주는 메서드. 외래키 조건에 따라 삭제 순서를 조정해야한다.

⇒ 상황에 따라 혼용하여 사용하는 것이 좋다.

-------

### @ParameterizedTest
    하나의 테스트에 여러가지 케이스를 테스트할 수 있게 해주는 JUnit Annotation

### @DynamicTest
    하나의 환경에서 여러가지 시나리오를 테스트 할 수 있게 해주는 JUnit Annotation

-------

### 테스트 환경 통합
- 테스트 수행도 비용이다. 관리가 필요하다
- 같은 @SpringBootTest 환경으로 작업을 하더라도 profile 지정이라던가 띄워 놓은 환경이 조금이라도 달라지면 SpringBoot 서버가 별도로 뜨게된다.
- 공통적으로 쓰이는 환경을 모아서 서버를 띄워주면 서버가 새로 뜨는 시간은 줄일 수 있게된다.

-----
### private 메서드 테스트
-  private 메서드는 테스트 할 필요가 없다. 테스트 해야 된다고 생각이 든다면 객체를 분리 해야할 시점인지 확인해봐야한다.
- 객체를 사용하는 클라이언트 입장에서 외부로 노출되는 기능만 알면 되지 내부에서 동작하는 기능을 알 필요가 없다
- public 메서드를 테스트하다 보면 자연스럽게 private 메서드가 호출되어 자동으로 검증이 된다