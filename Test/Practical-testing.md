  ## 개요
 > [인프런] Practical Testing: 실용적인 테스트 가이드를 학습하며 작성하였습니다.

------------
 ### 테스트가 필요한 이유는 무엇일까?
    - 테스트 코드가 없다면 프로덕션 코드를 계속 개발하고 고도화 하면서..
    - 커버할 수 없는 영역 발생
    - 프로젝트를 오래 작업한 개발자의 경험과 감에 의존
    - 늦은 피드백
    - 유지보수 어려움
    - 소프트웨어 신뢰 ↓ 어디서 버그가 터질지 모르는 시한폭탄이 될 수 있다


### 테스트를 추가하면서 얻고자 하는 것
    - 빠른 피드백
    - 자동화
    - 안정감, 신뢰성

### 테스트 코드를 작성하지 않는다면
    - 변화가 생기는 매 순간마다 발생할 수 있는 모든 Case를 고려해야 한다
    - 변화가 생기는 매 순간마다 모든 팀원이 동일한 고민을 해야한다
    - 빠르게 변화하는 소프트웨어의 안정성을 보장할 수 없다

### 테스트 코드가 병목이 된다면
    - 프로덕션 코드의 안정성을 제공하기 힘들어진다
    - 테스트 코드 자체가 유지보수하기 어려운, 새로운 짐이 된다
    - 잘못된 검증이 이루어질 가능성이 생긴다

### 올바른 테스트 코드는
    - 자동화 테스트로 비교적 빠른 시간 안에 버그를 발견할 수 있고, 수동 테스트에 드는 비용을 크게 절약할 수 있다
    - 소프트웨어의 빠른 변화를 지원한다
    - 팀원들의 집단 지성을 팀 차원의 이익으로 승격시킨다
    - 가까이 보면 느리지만, 멀리 보면 가장 빠르다

---

### 단위 테스트
- 작은 코드 단위(class or method)를 독립적으로 검증하는 테스트
- 검증 속도가 빠르고, 안정적이다
- JUnit5: 단위 테스트를 위한 테스트 프레임워크
    - XUnit 시리즈(SUnit, NUnit, JUnit 등등..) - 개발자: Kent Beck
- AssertJ: 테스트 코드 작성을 원활하게 돕는 테스트 라이브러리
    - 풍부한 API, 메서드 체이닝 지원
    - 주로 JUnit과 함께 사용

### 테스트 케이스 세분화하기
- 요구사항이 생겼을 때, 암묵적이거나 아직 드러나지 않은 요구 사항이 있는지 질문을 계속 던져야 한다
    → 암묵적으로 숨어있는 예외 케이스를 도출하여 작성해야 한다
- 해피 케이스: 요구사항을 만족하는 테스트 케이스
- 예외 케이스: 요구사항에 대한 예외 케이스

- 경계값 테스트
    - 범위(이상, 이하, 초과, 미만), 구간, 날짜 등

### 테스트하기 어려운 영역을 구분하고 분리하기

- 테스트하기 어려운 영역
    - 관측할 때마다 다른 값에 의존하는 코드
        ex) 현재 날짜/시간, 랜덤 값, 전역 변수/함수, 사용자 입력
    - 외부 세계에 영향을 주는 코드
        ex) 표준 출력, 메시지 발송(메일 전송), 데이터베이스에 기록하기
        
- 순수함수 (pure functions: 외부 세계와 단절된 함수)
    - 같은 입력에는 항상 같은 결과
    - 외부 세상과 단절된 형태
    - 테스트하기 쉬운 코드
- 테스트 하기 어려운 영역을 외부로 분리하자
    - 외부로 분리할수록 테스트 가능한 코드는 많아진다
    - 어느 외부까지 분리를 해야할까요?
    
--------

### TDD: Test Driven Development
- 프로덕션 코드보다 테스트 코드를 먼저 작성하여 테스트가 구현 과정을 주도하도록 하는 방법론
    - RED: 실패하는 테스트 작성
        - 포로덕션 코드(구현부)가 없으니 당연히 에러 발생
    - GREEN: 빠른 시간내에 테스트를 통과하도록 구현부를 작성
        - 테스트만 통과할 수 있다면  엉터리여도 된다
        - 테스트가 통과할 수 있는 최소한의 코딩
    - REFACTOR
        - 테스트 통과를 유지하면서 구현 코드 개선
- 기존 선 기능 구현, 후 테스트 작성 시 단점
    - 테스트 자체의 누락 가능성
    - 특정 테스트 케이스(해피 케이스)만 검증할 가능성
    - 잘못된 구현을 다소 늦게 발견한 가능성
- 선 테스트 작성, 후 기능 구현시(TDD) 장점
    - 복잡도가 낮은(유연하며 유지보수가 쉬운), 테스트 가능한 코드로 구현할 수 있게 한다
    - 쉽게 발견하기 어려운 엣지(Edge) 케이스를 놓치지 않게 해준다
    - 구현에 대한 빠른 피드백을 받을 수 있다
    - 과감한 리팩토링이 가능해진다
- TDD: 관점의 변화
    - 테스트는 구현부 검증을 위한 보조 수던 → 테스트와 상호 작용하며 발전하는 구현부
    - 클라이언트 관점에서 피드백을 주는 Test Driven

------
### 테스트는 문서다
    - 프로덕션 기능을 설명하는 테스트 코드 문서
    - 다양항 테스트 케이스를 통해 프로덕션 코드를 이해하는 시각과 관점을 보완
    - 어느 한 사람이 과거에 경험했던 고민의 결과물을 팀 차원으로 승격시켜서, 모두의 자산으로 공유 가능

-----

### BDD: Behavior Driven Development

- TDD에서 파생된 개발 방법
- 함수 단위의 테스트에 집중하기보다, 시나리오에 기반한 테스트 케이스(TC) 자체에 집중하여 테스트 한다
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 수준(레벨)을 권장
- given: 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 등)
- when:  시나리오 행동 진행
- then : 시나리오 진행에 대한 결과 명시, 검증
- 어떤 환경에서 (given) 어떤 행동을 진행했을 때 (when) 어떤 상태 변화가 일어난다 (then)
    
    ⇒ DisplayName에 명확하게 작성할 수 있다
    
-----

### 통합 테스트

    - 여러 모듈이 협력하는 기능을 통합적으로 검증하는 테스트
    - 일반적으로 작은 범위의 단위 테스트만으로는 기능 전체의 신뢰성을 보장할 수 없다
    - 풍부한 단위 테스트 & 큰 기능 단위를 검증하는 통합 테스트

### Spring 

- Library vs Framework 차이
    - Library 같은 경우는 내 코드가 주체가 된다.
        - 필요한 기능을 외부에 있는 이미 개발된 기능을 가져와서 사용
    - Framework 이미 동작할 수 있는 환경이 구성된 Frame이 있어서 내 코드가 수동적으로 이 Frame안에 들어가서 기능을 수행하게 됨
- IoC (Inversion of Control)
    - 객체의 생명주기를 3자가 주관하게 되는 것
- DI (Dependency Injection)
    - 의존성을 외부에서 주입받는 것
- AOP (Aspect Oriented Programming)
    - 비즈니스 흐름과 관계없는 부분 = 관점을 모아서 모듈로 분리
    - spring에서는 proxy를 사용하여 구현하고 있다
    - ex) transaction
    
----

### JPA

- ORM (Object-Relational Mapping)
    - 객체 지향 패러다임과 관계형 DB 패러다임의 불일치
    - 이전에는 개발자가 객체의 데이터를 하나씩 매핑하여 DB에 저장 및 조회
    - ORM을 사용함으로써 개발자는 단순 작업을 줄이고, 비즈니스 로직에 집중할 수 있다
- JPA
    - Java 진영의 ORM 기술 표준
    - 인터페이스이고, 여러 구현제가 있지만 보통 Hibernate를 많이 사용
    - 반복적인 CRUD SQL을 생성 및 실행해주고, 여러 부가 기능들을 제공한다
    - 편리하지만 쿼리를 직접 작성하지 않기 때문에, 어떤 식으로 쿼리가 만들어지고 실행되는지 명확하게 이해하고 있어야 한다
    - Spring 진영에서는 JPA를 한번 더 추상화한 Spring Data JPA 제공
    - QueryDSL과 조합하여 많이 사용 (타입 체크, 동적 쿼리)

----

### Layerd Architecture
    왜 레이어를 분리하는가? → 관심사의 분리

- Persistence Layer
    - Data Access의 역활
    - 비즈니스 가공 로직을 포함하면 안된다
    - Data에 대한 CRUD에만 집중한 레이어

- Business Layer
    - 비즈니스 로직을 구현하는 역할
    - Persistence Layer와의 상호작용을 통해 비즈니스 로직 전개
    - 트랜잭션을 보장해야 한다

- Presentation Layer
    - 외부 세계의 요청을 가장 먼저 받는 계층
    - 파라미터에 대한 최소한의 검증을 수행한다
        - 비즈니스 로직X

-----

### @Transactional

- readOnly = true 값의 의미는? (readOnly의 기본 값은 false이다)
    - 읽기 전용 트랜잭션
    - CRUD에서 CUD 동작 X / 조회만 가능
    - JPA에서는 CUD 스냅샷 저장, 변경감지 X (성능 향상)
    - CQRS - Command / Read
        - 보통의 서비스는 Read작업이 Command보다 훨씬 많음
        - DB에 대한 Endpoint를 분리할 수 있어 장애 격리를 할 수 있음        
            ex) master = write / slave = read

-----

### MockMvc

- Mock(가짜) 객체를 사용해 스프링 MVC 동작을 재현할 수 있는 프레임워크

------

#### Q. 서비스 테스트를 하면 이전에 한 테스트 데이터끼리 영향을 끼치고 있어서 @AfterEach 메소드를 통해 테스트가 끝나면 clear해주는 로직을 구성해야한다. 하지만 Repository를 테스트하였을 땐 clear를 해주지 않아도 되는데 이유가 무엇일까?
    - Repository 테스트를 할 때에는 Rollback으로 인한 clear가 이루어진다.
        - Service 는 SpringBootTest 어노테이션을 달아 테스트하였다.
        - Repository는 DataJpaTest 어노테이션을 달아 테스트하였다.
    - DataJpaTest 안에는 Transactional 이 걸려있어 자동으로 롤백이 된다. (SpringBootTest 에는 없음)

#### Q. DataJpaTest처럼 SpringBootTest 쓸 때 Transactional 어노테이션을 수동으로 붙여 사용하면 되지 않나요?

    - 수동으로 어노테이션을 붙였을 때 테스트 완료 후 따로 Clear하지 않아도 Rollback이 된다.
    - Test코드에 Transactional을 붙여서 사용하면 안되는 이유?
        - 테스트 코드가 아닌 프로덕션 코드에 트랜잭션이 설정되어있는지 모호해진다
        - 트랜잭션 경계가 모호해진다. (큰 이슈 발생 가능)
