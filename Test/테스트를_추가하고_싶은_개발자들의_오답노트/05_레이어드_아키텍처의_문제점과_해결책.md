## H2

### 모든 테스트가 H2를 필요로 한다

    h2를 사용하는 순간 그 테스트는 중형 테스트가 된다.

    예시 프로젝트에는 소형 테스트가 없음 ⇒ 테스트를 돌릴때 마다 부담이 된다

    이것은 설계가 잘못되었다는 신호!

### 문제점

- 설계가 잘못되었을 확률
- 지금 작성한 테스트가 실제로 테스트가 필요한 본질이 아닐 확률



## 레이어드 아키텍처

### 단점

    1. DB주도 설계
        
        : 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다
        
    2. 동시 작업을 할 수 없다
        
        :  모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 
        그 다음 도메인, 마지막 웹 계층을 만들어야 하기에 한 명의 개발자만 작업할 수 있다
        
        = 절차 지향적인 코드를 짰을 때 발생하는 문제
        
    3. 도메인이 죽는다
        
        : 코드에서 도메인이 눈에 안들어온다.
        
        사실상 서비스에서 모든 일을 다 처리하게 됨 (=fat servive)
        
    4. 의존성에 대한 고민을 유도하지 않는다

    5. 규모가 커질수록 확장성이 떨어진다

#### 결과적으로 레이어드 아키텍처를 사용하게 되면 절차지향적 사고를 유도하고, 낮은 Testability와 Bad SOLID를 하게된다

------

# 개선하기
### 1. 죽은 도메인

    : 비즈니스 문제를 해결하는 객체, 도메인을 살려 서비스가 하던 역할을 도메인이 처리하도록 위임

    - 서비스는 Repository에서 도메인을 가져와 도메인에게 일을 시키는(책임을 위임) 하는 곳
    - 도메인에서 실제 업무를 진행. OOP스러운 도메인들이 협력하는 곳
        - 도메인에서 사용하는 도메인 모델에는 lombok을 제외한 어노테이션이 없는 객체로 생성
            
            (도메인 객체와 영속성 Entity를 구분)
        

### 2. SOLID & 동시 작업

     도메인 아키텍처를 이용하며 해결이 될 것이다

### 3. 낮은 Testability

    - 도메인 레이어에서는 계층간 연결된 의존성이 없다 (=mocking할 필요가 없다)

    - JpaRepostory 또한 계층간 연결된 의존성이 없다

    - 비즈니스 레이어에서는 도메인과 Repository 2개의 의존성을 갖고있다.
        - domain 같은 경우에는 순수 java 코드로 이루어져 있기 때문에 인스턴스화 하는 것은 어렵지 않음
        - Repository 같은 경우에는 DB와 강결합 되어있는 JPA 코드를 인스턴스화 하는 것은 어려움

    - 의존성으로 발생하는 문제는 의존성 역전을 활용하여 해결하기
        - 비즈니스 레이어에서 Repository 인터페이스를 위치 시킴
            ⇒ 이것으로 인해 테스트할 때 Fake를 사용하게 함으로써, Testability를 높일 수 있다
        - 서비스는 Repository와의 의존성을 낮추게 됨으로 mysql을 쓰던 mongoDB를 쓰던 영향을 받지 않게 된다

    - Controller는 인스턴스화는 쉽지만 3개의 의존성이 필요
        - 서비스를 인터페이스를 만들어 의존성 역전 활용