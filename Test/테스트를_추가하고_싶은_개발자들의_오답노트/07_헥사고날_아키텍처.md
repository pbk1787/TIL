### 아키텍처와 테스트의 상호 관계
    - 테스트하기가 힘들다면 아키텍처가 잘못된 설계일 수 있다
    - 테스트하기 쉬운 쪽으로 개발하는 것이 정답일 확률이 높다

## 아키텍처란?
- 어떤 비즈니스 문제를 해결하기 위해, 준수해야하는 제약을 넣는 과정
- 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다.
- 아키텍처를 하다보면 왜 굳이 이렇게 까지 해야하지? 라는 의문이 들기도 한다 (아키텍처를 성실히 지킬수록 오히려 더 불편해지는 기현상이 발생)
    
    ⇒ 그럼에도 아키텍처를 사용하는 이유는 “꼭 써야하는 이유가 있으니까”이다. 아키텍처를 사용하기 전에 문제 상황과 써야하는 이유를 구성원들이 공감하게 만드는 것이 중요

### 아키텍트의 목표
- 인적 자원 절감
    - 동시 작업이 가능해야한다
    - 관심사를 분리해야 한다
    - 경계를 나눠야한다
        - 의존성 역전은 경계를 만드는 방법 중 하나
- 정책을 만들고 세부사항을 미루는 시스템 개발
    - 세부사항이란?
        - DB 종류나 웹서버, 프레임워크 등을 말한다
        - 세부사항을 결정하는 것 보다 **도메인**이 먼저 개발되어야 한다


### 의존성 역전의 경계
- 관심사를 분리하고 싶다 = 고립시키고 싶다 = 서로에게 영향을 받고 싶지 않다
- 포트(인터페이스) - 어댑터 패턴
    - Input Adapter - Input Port
    - output port - output Adapter

## 헥사고날 아키텍처
- 진화하는 아키텍처
    - port-adapter 패턴 적용 → 의미 없어진 계층 제거
- 장점
    - 도메인으로 향하는 방향이 단방향이다
    - JPA나 Spring과 같은 외부 세계에는 관심이 없어지고 개발자들이 오롯히 도메인에 집중할 수 있게 된다.
    - 테스트에 유리하다
- 클린 아키텍처란?
    - 개발 세계에서 아키텍처를 어떻게 다뤄야 깨끗하게 다룰 수 있는가를 이야기한 내용
    - 헥사고날은 클린 아키텍처를 실천하기 위해 나온 아키텍처
    - 헥사고날과의 용어 차이
        - input port → useCase
        - ouput port → gateway
        - 나머지 외부 세계: humble

### 헥사고날 vs 레이어드 아키텍처

- 레이어드 아키텍처의 문제점
    - 레이어드 아키텍처를 상향식으로 바라볼 때 DB위주로 사고하게 된다. JPA를 먼저 생각하게됨
    - 하향식으로 접근할 때에도 컨트롤러, 프레임 워크를 먼저 생각하게 된다
- 헥사고날 아키텍처
    - 헥사고날의 접근법은 상향식일때 자연스럽다.
        - 도메인 > serviceImpl > interface(service/repository) >  controller/repositoryImpl

-----

### 험블 객체 패턴
- 본질과 험블을 구분해야하는 이유
    - DB를 바꾼다고 계산 로직이 변경되면 안된다
    - 라이브러리를 바꾼다고 계산 로직이 변경되면 안된다
    - 프레임워크가 바뀐다고 계산 로직이 변경되면 안된다
    - 더 나아가 언어를 바꾼다고 계산 로직이 변경되면 안된다
    
    ⇒ 도메인을 설계하는 힘이 훨씬 중요하다

----

### 어댑터와 유스케이스
#### 어댑터의 역할
- Input 어댑터 (웹 어댑터)
    - Contorller의 역할은 무엇인지?
    1. HTTP 요청을 자바 객체로 매핑 ⇒ 스프링
    2. 권한 검사 ⇒ 스프링 시큐리티
    3. 입력 유효성 검증 ⇒ @Valid
    4. 입력을 유스케이스의 입력 모델로 매핑
    5. 유스케이스 호출
    6. 유스케이스의 출력을 HTTP로 매핑
    7. HTTP 응답을 반환 ⇒ 스프링
- Output 어댑터 (JPA 어댑터)
    - Repository 구현체가 어떤 역할을 해야하는가?
    1. 입력을 받는다
    2. 입력을 영속성 객체로 바꾼다 / 입력을 테이터베이스 포맷으로 매핑한다
    3. 영속성 객체를 저장한다 / 입력을 데이터베이스로 보낸다
    4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다
    5. 출력을 반환한다

#### 유스케이스의 중요성
- 개발자가 인식하는 애플리케이션
    - use case가 없다면 어떤 시스템인지 인식이 되지 않는다
        - ex) react front app ← 무엇을 하는 리액트 프론트앱인지 모름
- 플랫폼에 집착하면 안된다

-----
### 모델
#### 모델은 어디까지 세분화해야 하는가?
- Domain Entity와 JPA entity를 분리 해야하는가?
1. 단일 모델
    
    : 단일 모델 하나를 두고, 모든 컴포넌트(Controller, Service, repository 등)에서 이 모델 하나만 사용하게 하는 것
    
    ⇒ 사실상 현업에서는 불가능한 구조
    
2. 웹 어댑터를 위한 모델
    - 웹 어댑터의 역할: 유스케이스의 출력을 HTTP 응답으로 매핑
    - 중요한 정보가 포함되어있을 수 있으니 사용하는 응답 값만 보내주기 위해 http 응답 모델이 필요하다, 비슷한 이유로 requestBody를 받아주는 http 입력 모델도 필요함
    
3. Jpa 어댑터를 위한 모델
    - 분리하지 않으면 도메인이 DB에 종속되고 ORM과 결합이 생긴다

        ⇒ 3단 분류 하여 웹 모델/도메인 모델/영속성 모델로 구분

4. in port 모델
    - 많은 파라미터들을 메소드 파라미터로 나열하면 가독성이 떨어지게 된다
    - HTTP Request를 UseCase로 바로 건네면 의존하게 되면서 순환 참조가 생겨버린다
        - 하위 모듈이 상위 모델에 의존하는 경계가 무너지는 상황이 발생
    - 마찬가지 이유로 out port 모델도 필요함

⇒ 정리하자면.. 웹 모델/Input 포트 모델/도메인 모델/output 포트 모델/영속성 모델이 필요하게 됨

- 단방향 매핑전략
    - 이 모든 것은 하나의 도메인에서 파생되었기 때문에 모든 개념의 상위 인터페이스인 State같은 인터페이스를 두어 사용한다

⇒ 정답은 없으니 원칙과 편의성 사이에서 잘 고려하여 세분화 해야한다.

작은 토이 프로젝트를 만드는데 많이 세분화 할 필요가 없으니 …